import threading

class DiningPhilosophers:
    def __init__(self):
        # Create locks for the 5 forks
        self.forks = [threading.Lock() for _ in range(5)]

    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):
        left_fork = philosopher  # Left fork index
        right_fork = (philosopher + 1) % 5  # Right fork index

        # To prevent deadlock, ensure a consistent locking order (e.g., lock the smaller index first)
        first_fork, second_fork = (left_fork, right_fork) if left_fork < right_fork else (right_fork, left_fork)

        # Lock the forks in the correct order
        with self.forks[first_fork]:
            with self.forks[second_fork]:
                # Pick up both forks
                pickLeftFork()
                pickRightFork()
                
                # Eat
                eat()

                # Put down both forks
                putLeftFork()
                putRightFork()

# Example usage
if __name__ == "__main__":
    import time
    import random

    def pickLeftFork():
        output.append([philosopher_id, 1, 1])

    def pickRightFork():
        output.append([philosopher_id, 2, 1])

    def eat():
        output.append([philosopher_id, 0, 3])
        time.sleep(random.uniform(0.01, 0.1))  # Simulate eating time

    def putLeftFork():
        output.append([philosopher_id, 1, 2])

    def putRightFork():
        output.append([philosopher_id, 2, 2])

    n = 1  # Number of times each philosopher eats
    output = []
    philosophers = DiningPhilosophers()

    threads = []
    for philosopher_id in range(5):
        for _ in range(n):
            t = threading.Thread(target=philosophers.wantsToEat,
                                 args=(philosopher_id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork))
            threads.append(t)

    for t in threads:
        t.start()

    for t in threads:
        t.join()

    print(output)
